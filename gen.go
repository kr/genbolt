package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"io"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"golang.org/x/tools/go/loader"
)

var prog *loader.Program

func gen(name string) (code []byte, err error) {
	cfg := loader.Config{
		ParserMode: parser.ParseComments,
	}
	cfg.CreateFromFilenames("", name)
	prog, err = cfg.Load()
	if err != nil {
		return nil, err
	}
	if n := len(prog.Created); n != 1 {
		return nil, fmt.Errorf("got %d packages, want 1", n)
	}
	for _, pi := range prog.Created {
		for _, file := range pi.Files {
			var b bytes.Buffer
			fmt.Fprintln(&b, "// Generated by github.com/kr/genbolt. DO NOT EDIT.")
			fmt.Fprintln(&b, "// See", name)
			fmt.Fprintln(&b)
			err = genFile(&b, file, pi, prog)
			if err != nil {
				return nil, err
			}
			return format.Source(b.Bytes())
		}
	}
	panic("unreached")
}

type rootInfo struct {
	S string // name suffix, e.g. "Foo" in "RootFoo"
	C *ast.CommentGroup
}

type fieldInfo struct {
	B string // bucket (struct type name)
	F string // field name
	T string // type name of field
	C *ast.CommentGroup

	JSONTypes map[*types.Named]bool
	Type      *types.Named
}

func genFile(w io.Writer, file *ast.File, pi *loader.PackageInfo, prog *loader.Program) error {
	pkg := pi.Pkg
	scope := pkg.Scope()
	typeString := func(t types.Type) string {
		return types.TypeString(t, (*types.Package).Name)
	}
	keys := make(map[string]bool)
	fmt.Fprintln(w, "package", pkg.Name())
	fmt.Fprintln(w)
	type container struct {
		Type string
		Elem string
	}
	type jsonContainer struct {
		Type      string
		Elem      string
		FieldInfo fieldInfo
	}

	var userImports []*types.Package
	jsonTypes := make(map[*types.Named]bool)
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.VAR {
			continue
		}
		for _, spec := range genDecl.Specs {
			vs := spec.(*ast.ValueSpec)
			iface := pi.Types[vs.Type].Type
			if iface == nil {
				return fmt.Errorf("interface assertion has no interface: %v", esprint(vs))
			}
			if n, ok := iface.(*types.Named); !ok || n.String() != "encoding/json.Marshaler" {
				return fmt.Errorf("unsupported interface: %v", n)
			}

			for i, value := range vs.Values {
				if vs.Names[i].Name != "_" {
					return fmt.Errorf("interface assertion has non-_ name: %v", esprint(vs))
				}
				convType := pi.Types[value].Type
				ptr, ok := convType.(*types.Pointer)
				if !ok {
					return fmt.Errorf("interface assertion has bad expression (must be pointer to named type): %v", esprint(convType))
				}
				named, ok := ptr.Elem().(*types.Named)
				if !ok {
					return fmt.Errorf("interface assertion has bad expression (must be pointer to named type): %v", esprint(convType))
				}
				jsonTypes[named] = true
				userImports = append(userImports, named.Obj().Pkg())
			}
		}
	}

	if len(jsonTypes) > 0 {
		fmt.Fprintln(w, `import json "encoding/json"`)
	}
	seenNames := make(map[string]bool)
	for _, pkg := range userImports {
		if seenNames[pkg.Name()] {
			return fmt.Errorf("duplicate package name %s", pkg.Name())
		}
		seenNames[pkg.Name()] = true
		// TODO(kr): use package label from input file (also gives uniqueness)
		fmt.Fprintf(w, "import %s %q\n", pkg.Name(), pkg.Path())
	}
	fmt.Fprintln(w, imports)

	mapTypes := make(map[string]*container)
	jsonMapTypes := make(map[string]*jsonContainer)
	seqTypes := make(map[string]*container)
	jsonSeqTypes := make(map[string]*jsonContainer)
	needBucket := false
	needPut := false
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			return fmt.Errorf("unexpected decl: %v", esprint(decl))
		}
		switch genDecl.Tok {
		case token.VAR, token.IMPORT:
			continue
		case token.TYPE: // ok, proceed
		default:
			return fmt.Errorf("unexpected decl: %v", esprint(decl))
		}
		for _, spec := range genDecl.Specs {
			spec := spec.(*ast.TypeSpec)
			if spec.Assign != 0 {
				return fmt.Errorf("unexpected decl: %v", esprint(decl))
			}
			structType, ok := spec.Type.(*ast.StructType)
			if !ok {
				return fmt.Errorf("need struct type")
			}

			fmt.Fprintln(w)

			isRoot, rootSuffix := false, ""
			if s := spec.Name.Name; strings.HasPrefix(s, "Root") {
				rootSuffix = s[4:]
				isRoot = s == "Root" || ast.IsExported(rootSuffix)
			}

			if isRoot {
				templateRoot.Execute(w, rootInfo{
					S: rootSuffix,
					C: genDecl.Doc,
				})
			}

			if genDecl.Doc != nil {
				for _, c := range genDecl.Doc.List {
					fmt.Fprintln(w, c.Text)
				}
			}
			fmt.Fprintln(w, "type", spec.Name, "struct {")
			if isRoot {
				fmt.Fprintln(w, "\tdb *bolt.Tx")
			} else {
				fmt.Fprintln(w, "\tdb *bolt.Bucket")
			}
			fmt.Fprintln(w, "}")
			fmt.Fprintln(w)
			if isRoot {
				fmt.Fprintln(w, "func (o *", spec.Name, ") Tx() *bolt.Tx {")
			} else {
				fmt.Fprintln(w, "func (o *", spec.Name, ") Bucket() *bolt.Bucket {")
			}
			fmt.Fprintln(w, "return o.db")
			fmt.Fprintln(w, "}")

			for _, field := range structType.Fields.List {
				for _, name := range field.Names {
					if !name.IsExported() {
						return fmt.Errorf("all fields must be exported")
					}
					if isReserved(name) {
						return fmt.Errorf("field name %s is reserved (sorry)", name.Name)
					}
					keys[name.Name] = true

					// TODO(kr): change this switch to use go/types
					switch fieldType := field.Type.(type) {
					case *ast.Ident:
						if !isBasic(scope, fieldType.Name) {
							return fmt.Errorf("unsupported type %s (try *%s instead?)", fieldType.Name, fieldType.Name)
						}
						if isRoot {
							return fmt.Errorf("unsupported root field type %s", esprint(field.Type))
						}
						templateField.Execute(w, fieldInfo{
							B: spec.Name.Name,
							F: name.Name,
							T: fieldType.Name,
							C: field.Doc,
						})
						needPut = true
					case *ast.StarExpr:
						switch typ := fieldType.X.(type) {
						case *ast.Ident:
							// TODO(kr): look up typeName.Name and make sure it's a struct.
							templatePointerField.Execute(w, fieldInfo{
								B: spec.Name.Name,
								F: name.Name,
								T: typ.Name,
								C: field.Doc,
							})
							needBucket = true
						default:
							t, _ := pi.Types[typ].Type.(*types.Named)
							_, ok := jsonTypes[t]
							if !ok {
								return fmt.Errorf("cannot marshal %v; please implement json.Marshaler", esprint(fieldType.X))
							}
							templateField.Execute(w, fieldInfo{
								B: spec.Name.Name,
								F: name.Name,
								T: "*" + typeString(t),
								C: field.Doc,

								Type:      t,
								JSONTypes: jsonTypes,
							})
							needPut = true
						}
					case *ast.ArrayType:
						if fieldType.Len != nil {
							return fmt.Errorf("cannot have array type (use a slice)")
						}

						switch elemType := fieldType.Elt.(type) {
						case *ast.Ident:
							if !isBasic(scope, elemType.Name) {
								return fmt.Errorf("unsupported type %s (try *%s instead?)", elemType.Name, elemType.Name)
							}
							templateField.Execute(w, fieldInfo{
								B: spec.Name.Name,
								F: name.Name,
								T: "[]" + elemType.Name,
								C: field.Doc,
							})
							needPut = true
						case *ast.StarExpr:
							switch typ := elemType.X.(type) {
							case *ast.Ident:
								// TODO(kr): look up typ.Name and make sure
								// it's a struct.
								seqType := typ.Name + "Seq"
								seqTypes[seqType] = &container{
									Type: seqType,
									Elem: typ.Name,
								}
								templatePointerField.Execute(w, fieldInfo{
									B: spec.Name.Name,
									F: name.Name,
									T: seqType,
									C: field.Doc,
								})
								needBucket = true
							default:
								t, _ := pi.Types[typ].Type.(*types.Named)
								_, ok := jsonTypes[t]
								if !ok {
									return fmt.Errorf("cannot marshal %v; please implement json.Marshaler", esprint(elemType.X))
								}

								pkg := t.Obj().Pkg().Name()
								ru, n := utf8.DecodeRuneInString(pkg)
								seqType := string(unicode.ToUpper(ru)) + pkg[n:] + t.Obj().Name() + "Seq"
								jsonSeqTypes[seqType] = &jsonContainer{
									Type: seqType,
									Elem: typeString(t),
									FieldInfo: fieldInfo{
										Type:      t,
										JSONTypes: jsonTypes,
									},
								}

								templatePointerField.Execute(w, fieldInfo{
									B: spec.Name.Name,
									F: name.Name,
									T: seqType,
									C: field.Doc,
								})
								needBucket = true
								needPut = true
							}
						default:
							return fmt.Errorf("slice element must be pointer to struct or basic type")
						}
					case *ast.MapType:
						keyType, ok := fieldType.Key.(*ast.Ident)
						if !ok || keyType.Name != "string" {
							return fmt.Errorf("map key must be string")
						}
						valueType, ok := fieldType.Value.(*ast.StarExpr)
						if !ok {
							return fmt.Errorf("map value must be pointer to named struct type")
						}

						switch typ := valueType.X.(type) {
						case *ast.Ident:
							mapType := typ.Name + "Map"
							mapTypes[mapType] = &container{
								Type: mapType,
								Elem: typ.Name,
							}

							templatePointerField.Execute(w, fieldInfo{
								B: spec.Name.Name,
								F: name.Name,
								T: mapType,
								C: field.Doc,
							})
							needBucket = true
						default:
							t, _ := pi.Types[typ].Type.(*types.Named)
							_, ok := jsonTypes[t]
							if !ok {
								return fmt.Errorf("cannot marshal %v; please implement json.Marshaler", esprint(valueType.X))
							}

							pkg := t.Obj().Pkg().Name()
							ru, n := utf8.DecodeRuneInString(pkg)
							mapType := string(unicode.ToUpper(ru)) + pkg[n:] + t.Obj().Name() + "Map"
							jsonMapTypes[mapType] = &jsonContainer{
								Type: mapType,
								Elem: typeString(t),
								FieldInfo: fieldInfo{
									Type:      t,
									JSONTypes: jsonTypes,
								},
							}

							templatePointerField.Execute(w, fieldInfo{
								B: spec.Name.Name,
								F: name.Name,
								T: mapType,
								C: field.Doc,
							})
							needBucket = true
							needPut = true
						}
					default:
						return fmt.Errorf("unsupported type %v", esprint(field.Type))
					}
				}
			}
		}
	}
	templateMapType.Execute(w, mapTypes)
	templateSeqType.Execute(w, seqTypes)
	templateJSONMapType.Execute(w, jsonMapTypes)
	templateJSONSeqType.Execute(w, jsonSeqTypes)
	templateKeys.Execute(w, keys)
	if needBucket {
		fmt.Fprintln(w, bucket)
	}
	if needPut {
		fmt.Fprintln(w, put)
	}
	return nil
}

func esprint(node interface{}) string {
	var b bytes.Buffer
	printer.Fprint(&b, prog.Fset, node)
	return b.String()
}

func isBasic(scope *types.Scope, name string) bool {
	obj := scope.Lookup(name)
	if obj == nil && scope == types.Universe {
		return false
	}
	if obj == nil {
		return isBasic(types.Universe, name)
	}
	_, ok := obj.Type().(*types.Basic)
	return ok
}

func isReserved(name *ast.Ident) bool {
	switch name.Name {
	case "Tx", "Bucket":
		return true
	}
	return false
}

var tlib = template.Must(template.New("lib").Parse(`
{{define "get"}}
{{- if index .JSONTypes .Type -}}
	var x json.Unmarshaler = new({{.Type.Obj.Pkg.Name}}.{{.Type.Obj.Name}})
	err := json.Unmarshal(v, x)
	if err != nil {
		panic(err)
	}
	return x
{{- else if eq .T "[]byte" -}}
	c := make([]byte, len(v))
	copy(c, v)
	return c
{{- else if eq .T "string" -}}
	return string(v)
{{- else if eq .T "bool" -}}
	return v[0] != 0
{{- else if or (eq .T "byte") (eq .T "uint8") -}}
	return v[0]
{{- else if eq .T "uint16" -}}
	return binary.BigEndian.Uint16(v)
{{- else if eq .T "uint32" -}}
	return binary.BigEndian.Uint32(v)
{{- else if eq .T "uint64" -}}
	return binary.BigEndian.Uint64(v)
{{- else if eq .T "int8" -}}
	return int8(v[0])
{{- else if eq .T "int16" -}}
	return int16(binary.BigEndian.Uint16(v))
{{- else if eq .T "int32" -}}
	return int32(binary.BigEndian.Uint32(v))
{{- else if eq .T "int64" -}}
	return int64(binary.BigEndian.Uint64(v))
{{- else -}}
	panic("internal error") {{- /* never generated */}}
{{- end -}}
{{end}}

{{define "put"}}
{{- if index .JSONTypes .Type -}}
	v, err := json.Marshal(json.Marshaler(x))
	if err != nil {
		panic(err)
	}
{{- else if eq .T "[]byte" -}}
	v := x
{{- else if eq .T "string" -}}
	v := []byte(x)
{{- else if eq .T "bool" -}}
	v := make([]byte, 1)
	if x { v[0] = 1 }
{{- else if or (eq .T "byte") (eq .T "uint8") -}}
	v := []byte{x}
{{- else if eq .T "uint16" -}}
	v := make([]byte, 2)
	binary.BigEndian.PutUint16(v, x)
{{- else if eq .T "uint32" -}}
	v := make([]byte, 4)
	binary.BigEndian.PutUint32(v, x)
{{- else if eq .T "uint64" -}}
	v := make([]byte, 8)
	binary.BigEndian.PutUint64(v, x)
{{- else if eq .T "int8" -}}
	v := []byte{byte(x)}
{{- else if eq .T "int16" -}}
	v := make([]byte, 2)
	binary.BigEndian.PutUint16(v, uint16(x))
{{- else if eq .T "int32" -}}
	v := make([]byte, 4)
	binary.BigEndian.PutUint32(v, uint32(x))
{{- else if eq .T "int64" -}}
	v := make([]byte, 8)
	binary.BigEndian.PutUint64(v, uint64(x))
{{- else -}}
	panic("internal error") {{- /* never generated */}}
{{- end -}}
{{end}}
`))

var templateField = template.Must(template.Must(tlib.Clone()).Parse(`
{{if .C.Text -}}
{{range .C.List -}}
{{.Text}}
{{end -}}
{{end -}}
func (o *{{.B}}) {{.F}}() {{.T}} {
	v := o.db.Get(key{{.F}})
	{{template "get" .}}
}

// Put{{.F}} stores x as the value of {{.F}}.
{{if .C.Text -}}
//
{{range .C.List -}}
{{.Text}}
{{end -}}
{{end -}}
func (o *{{.B}}) Put{{.F}}(x {{.T}}) {
	{{template "put" .}}
	put(o.db, key{{.F}}, v)
}
`))

var templatePointerField = template.Must(template.Must(tlib.Clone()).Parse(`
{{if .C.Text -}}
{{range .C.List -}}
{{.Text}}
{{end -}}
{{end -}}
func (o *{{.B}}) {{.F}}() *{{.T}} {
	return &{{.T}}{bucket(o.db, key{{.F}})}
}
`))

var templateMapType = template.Must(template.Must(tlib.Clone()).Parse(`
{{range .}}
type {{.Type}} struct {
	db *bolt.Bucket
}

func (o *{{.Type}}) Bucket() *bolt.Bucket {
	return o.db
}

func (o *{{.Type}}) Get(key []byte) *{{.Elem}} {
	return &{{.Elem}}{bucket(o.db, key)}
}

func (o *{{.Type}}) GetByString(key string) *{{.Elem}} {
	{{/* TODO(kr): consider unsafe conversion */ -}}
	return &{{.Elem}}{bucket(o.db, []byte(key))}
}
{{end}}
`))

var templateJSONMapType = template.Must(template.Must(tlib.Clone()).Parse(`
{{range .}}
type {{.Type}} struct {
	db *bolt.Bucket
}

func (o *{{.Type}}) Bucket() *bolt.Bucket {
	return o.db
}

func (o *{{.Type}}) Get(key []byte) *{{.Elem}} {
	v := o.db.Get(key)
	{{template "get" .FieldInfo}}
}

func (o *{{.Type}}) GetByString(key string) *{{.Elem}} {
	{{/* TODO(kr): consider unsafe conversion */ -}}
	return o.Get([]byte(key))
}

func (o *{{.Type}}) Put(key []byte, x *{{.Elem}}) {
	{{template "put" .FieldInfo}}
	put(o.db, key, v)
}

func (o *{{.Type}}) PutByString(key string, x *{{.Elem}}) {
	{{/* TODO(kr): consider unsafe conversion */ -}}
	o.Put([]byte(key), x)
}
{{end}}
`))

var templateSeqType = template.Must(template.Must(tlib.Clone()).Parse(`
{{range .}}
type {{.Type}} struct {
	db *bolt.Bucket
}

func (o *{{.Type}}) Bucket() *bolt.Bucket {
	return o.db
}

func (o *{{.Type}}) Get(n uint64) *{{.Elem}} {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	return &{{.Elem}}{bucket(o.db, key)}
}

func (o *{{.Type}}) Add() (*{{.Elem}}, uint64) {
	n, err := o.db.NextSequence()
	if err != nil {
		panic(err)
	}
	return o.Get(n), n
}
{{end}}
`))

var templateJSONSeqType = template.Must(template.Must(tlib.Clone()).Parse(`
{{range .}}
type {{.Type}} struct {
	db *bolt.Bucket
}

func (o *{{.Type}}) Bucket() *bolt.Bucket {
	return o.db
}

func (o *{{.Type}}) Get(n uint64) *{{.Elem}} {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	v := o.db.Get(key)
	{{template "get" .FieldInfo}}
}

// Add adds x to the sequence.
// It writes the new sequence number to *np
// before marshaling x. Thus, it is okay for
// np to point to a field inside x, to store
// the sequence number in the new record.
func (o *{{.Type}}) Add(x *{{.Elem}}, np *uint64) {
	n, err := o.db.NextSequence()
	if err != nil {
		panic(err)
	}
	*np = n
	o.Put(n, x)
}

func (o *{{.Type}}) Put(n uint64, x *{{.Elem}}) {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	{{template "put" .FieldInfo}}
	put(o.db, key, v)
}
{{end}}
`))

var templateKeys = template.Must(template.Must(tlib.Clone()).Parse(`
var (
{{- range $name, $_ := .}}
	key{{$name}} = []byte({{printf "%q" $name}})
{{- end}}
)
`))

var templateRoot = template.Must(template.Must(tlib.Clone()).Parse(`
// NewRoot{{.S}} returns a new Root{{.S}} for tx.
{{if .C.Text -}}
//
{{range .C.List -}}
{{.Text}}
{{end -}}
{{end -}}
func NewRoot{{.S}}(tx *bolt.Tx) *Root{{.S}} {
	return &Root{{.S}}{tx}
}

func View{{.S}}(db *bolt.DB, f func(*Root{{.S}}) error) error {
	return db.View(func(tx *bolt.Tx) error {
		return f(&Root{{.S}}{tx})
	})
}

func Update{{.S}}(db *bolt.DB, f func(*Root{{.S}}) error) error {
	return db.Update(func(tx *bolt.Tx) error {
		return f(&Root{{.S}}{tx})
	})
}
`))

const imports = `
import binary "encoding/binary"
import bolt "github.com/coreos/bbolt"

const _ = binary.MaxVarintLen16
const _ = bolt.MaxKeySize
`

const bucket = `
type db interface {
	Writable() bool
	CreateBucketIfNotExists([]byte) (*bolt.Bucket, error)
	Bucket([]byte) *bolt.Bucket
}

func bucket(db db, key []byte) *bolt.Bucket {
	if !db.Writable() {
		return db.Bucket(key)
	}
	b, err := db.CreateBucketIfNotExists(key)
	if err != nil {
		panic(err)
	}
	return b
}
`

const put = `
func put(b *bolt.Bucket, key, value []byte) {
	err := b.Put(key, value)
	if err != nil {
		panic(err)
	}
}
`
