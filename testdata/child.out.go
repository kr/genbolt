// Generated by github.com/kr/genbolt. DO NOT EDIT.
// See testdata/child.in.go.

package db

import binary "encoding/binary"
import bolt "github.com/coreos/bbolt"

const _ = binary.MaxVarintLen16
const _ = bolt.MaxKeySize

// Root is a bucket with a static set of elements.
// Accessor methods read and write records
// and open child buckets.
// See functions View and
// Update to open transactions.
type Root struct {
	db *bolt.Tx
}

// NewRoot returns a new Root for tx.
func NewRoot(tx *bolt.Tx) *Root {
	return &Root{tx}
}

// View opens a read-only transaction
// and calls f with an instance of Root as the root bucket.
// It returns the error returned by f.
func View(db *bolt.DB, f func(*Root) error) error {
	return db.View(func(tx *bolt.Tx) error {
		return f(&Root{tx})
	})
}

// Update opens a writable transaction
// and calls f with an instance of Root as the root bucket,
// then it commits the transaction.
// It returns the error returned by f,
// or any error committing to the database, if f was successful.
func Update(db *bolt.DB, f func(*Root) error) error {
	return db.Update(func(tx *bolt.Tx) error {
		return f(&Root{tx})
	})
}

// Tx returns o's underlying *bolt.Tx object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
func (o *Root) Tx() *bolt.Tx {
	return o.db
}

// A is a bucket with a static set of elements.
// Accessor methods read and write records
// and open child buckets.
type A struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *A) Bucket() *bolt.Bucket {
	return o.db
}

// B is a bucket with a static set of elements.
// Accessor methods read and write records
// and open child buckets.
type B struct {
	db *bolt.Bucket
}

// Bucket returns o's underlying *bolt.Bucket object.
// This can be useful to access low-level database functions
// or other features not exposed by this generated code.
//
// Note, if o's transaction is read-only and the underlying
// bucket has not previously been created in a writable
// transaction, Bucket returns nil.
func (o *B) Bucket() *bolt.Bucket {
	return o.db
}

// A gets the child bucket with key "A" from o.
//
// A creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *A;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *Root) A() *A {
	return &A{bucket(o.db, keyA)}
}

// B gets the child bucket with key "B" from o.
//
// B creates a new bucket if none exists
// and o's transaction is writable.
// Regardless, it always returns a non-nil *B;
// if the bucket doesn't exist
// and o's transaction is read-only, the returned value
// represents an empty bucket.
func (o *A) B() *B {
	return &B{bucket(o.db, keyB)}
}

// N reads the record stored under key "N".
// If no record has been stored, N returns
// the zero value.
func (o *B) N() int32 {
	rec := get(o.db, keyN)
	if rec == nil {
		return 0
	}
	return int32(binary.BigEndian.Uint32(rec))
}

// PutN stores v as a record under the key "N".
func (o *B) PutN(v int32) {
	rec := make([]byte, 4)
	binary.BigEndian.PutUint32(rec, uint32(v))
	put(o.db, keyN, rec)
}

var (
	keyA = []byte("A")
	keyB = []byte("B")
	keyN = []byte("N")
)

type db interface {
	Writable() bool
	CreateBucketIfNotExists([]byte) (*bolt.Bucket, error)
	Bucket([]byte) *bolt.Bucket
}

func bucket(db db, key []byte) *bolt.Bucket {
	if bu, ok := db.(*bolt.Bucket); ok && bu == nil {
		return nil // can happen in read-only txs
	}
	if !db.Writable() {
		return db.Bucket(key)
	}
	b, err := db.CreateBucketIfNotExists(key)
	if err != nil {
		panic(err)
	}
	return b
}

func get(b *bolt.Bucket, key []byte) []byte {
	if b == nil {
		return nil
	}
	return b.Get(key)
}

func put(b *bolt.Bucket, key, value []byte) {
	err := b.Put(key, value)
	if err != nil {
		panic(err)
	}
}
