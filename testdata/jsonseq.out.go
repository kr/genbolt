// Generated by github.com/kr/genbolt. DO NOT EDIT.
// See testdata/jsonseq.in.go

package db

import json "encoding/json"
import sample "github.com/kr/genbolt/testdata/sample"

import binary "encoding/binary"
import bolt "github.com/coreos/bbolt"

const _ = binary.MaxVarintLen16
const _ = bolt.MaxKeySize

type T struct {
	db *bolt.Bucket
}

func (o *T) Bucket() *bolt.Bucket {
	return o.db
}

func (o *T) J() *SampleJSONSeq {
	return &SampleJSONSeq{bucket(o.db, keyJ)}
}

type SampleJSONSeq struct {
	db *bolt.Bucket
}

func (o *SampleJSONSeq) Bucket() *bolt.Bucket {
	return o.db
}

func (o *SampleJSONSeq) Get(n uint64) *sample.JSON {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	rec := o.db.Get(key)
	if rec == nil {
		return nil
	}
	var v json.Unmarshaler = new(sample.JSON)
	err := json.Unmarshal(rec, v)
	if err != nil {
		panic(err)
	}
	return v
}

// Add adds v to the sequence.
// It writes the new sequence number to *np
// before marshaling v. Thus, it is okay for
// np to point to a field inside v, to store
// the sequence number in the new record.
func (o *SampleJSONSeq) Add(v *sample.JSON, np *uint64) {
	n, err := o.db.NextSequence()
	if err != nil {
		panic(err)
	}
	*np = n
	o.Put(n, v)
}

func (o *SampleJSONSeq) Put(n uint64, v *sample.JSON) {
	key := make([]byte, 8)
	binary.BigEndian.PutUint64(key, n)
	rec, err := json.Marshal(json.Marshaler(v))
	if err != nil {
		panic(err)
	}
	put(o.db, key, rec)
}

var (
	keyJ = []byte("J")
)

type db interface {
	Writable() bool
	CreateBucketIfNotExists([]byte) (*bolt.Bucket, error)
	Bucket([]byte) *bolt.Bucket
}

func bucket(db db, key []byte) *bolt.Bucket {
	if !db.Writable() {
		return db.Bucket(key)
	}
	b, err := db.CreateBucketIfNotExists(key)
	if err != nil {
		panic(err)
	}
	return b
}

func put(b *bolt.Bucket, key, value []byte) {
	err := b.Put(key, value)
	if err != nil {
		panic(err)
	}
}
